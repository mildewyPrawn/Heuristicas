package main

import (
	"database/sql"
	"fmt"
	"sort"
	"math"
	"math/rand"
	_ "github.com/mattn/go-sqlite3"
)

const (
	// Constante del radio de la tierra aproximado
	radio = 6373000
	P = 0.90
	EPSILON = 0.0001
	EPSILONP = 0.0001
	L = 1000
	PHI = .9
	// Query para seleccionar conexiones
	QUERY_IDS = "SELECT distance FROM connections WHERE id_city_1 = ? AND id_city_2 = ?"
	// Query para seleccionar latitud y longitud
	QUERY_LAT_LON = "SELECT latitude, longitude FROM cities WHERE id = ?"

)

var database, _ = sql.Open("sqlite3", "./tsp.db")

// Datos generales
type General struct {
	aristasE []float64 // todas las aristas que se usan
	distancias [][]float64	// grafica completa
	normalizador float64 // normalizador
	maxDist float64 //maxima distancia
}

// Para cada par no ordenado, si la arista está en las distancias (tsp.sql), la
// agregamos a una lista
// Regresa todas las aristas en E
func totalAristas(ciudadesId []int, distancias [][]float64) []float64 {
	var totalAristas []float64
	for i := 0; i < len(ciudadesId); i++ {
		// ¿j = i?
		for j := 0; j < len(ciudadesId); j++ {
			// Si está en las distancias agregamos
			if distancias[i][j] != 0 {
				totalAristas = append(totalAristas, distancias[i][j])
			}
		}
	}
	sort.Float64s(totalAristas) // Ordenadonn de menor a mayor
	return totalAristas
}

// Regresa la suma de las últimas k aristas
// Recibe todas las aristas en E y todas las ciudades
func GetNormalizador(aristasE []float64, ciudadesId []int) float64 {
	suma := 0.0
	end := 0
	if  len(aristasE) < len(ciudadesId)-1{
		end = len(aristasE)
	} else {
		end = len(aristasE)-len(ciudadesId)
	}
	for i := len(aristasE)-1; i > end; i-- {
		suma += aristasE[i]
	}
	return suma
}

// Funcion que calcula el numerador de la funcion de costo, hay que divirlo
// entre el normalizador
// Recibe los id de las ciudades
// Recibe la matriz con las distancias
// Regresa la suma de las distancias de la arista (i, i-1)
func FunCostoSolucion(id []int, g General) float64 {
	normalizador := g.normalizador
	suma := 0.0
	for i := 1; i < len(id); i++ {
		suma += g.distancias[i-1][i]
		// suma += g.distancias[i][i-1]  // esta da mas cara por alguna extraña razon
	}
	return suma/normalizador
}

func obtenerLatLon(i int) (latitud, longitud float64) {
	var lat, lon float64
	rows, _ := database.Query(QUERY_LAT_LON, i)
	for rows.Next() {
		rows.Scan(&lat, &lon)
	}
	return radianes(lat), radianes(lon)
}

func llenaCompleta(ids []int, distancias [][]float64, maxDist float64) [][]float64 {
	for i := 0; i < len(ids); i++ {
		for j := 0; j < len(ids); j++ {
			if distancias[i][j] == 0 {
				distancias[i][j] = pesoAumentado(ids[i], ids[j], maxDist)
			}
		}
	}
	return distancias
}

///////
// CREO QUE SI METO TODO A LA GRÁFICA JALA MÁS RÁPIDO, PORQUE LO VUELVO A CALCULAR
//////
func completa(ciudades []int) [][]float64 {
	var matriz = [][]float64{}
	for i := 0; i < len(ciudades); i++ {
		adyacentes := make([]float64, len(ciudades))
		for j := 0; j < len(ciudades); j++ {
			var distance float64
			rows, _ := database.Query(QUERY_IDS, ciudades[i], ciudades[j])
			for rows.Next() {
				rows.Scan(&distance)
				adyacentes[j] = distance
			}
		}
		matriz = append(matriz, adyacentes)
	}
	return matriz
}


// Convierte una coordenada a radianes
// Regresa la coordenada en radianes
func radianes(coordenada float64) float64 {
	return (coordenada*math.Pi)/180
}

// Saca la distancia NATURAL
// Regresa la distancia natural entre dos ciudades dadas por su ID
func distanciaNatural(u, v int) float64 {
	a := obtenerA(u, v)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	return float64(radio) * c
}

// Regresa la formula 'A' del pdf
func obtenerA (u, v int) float64 {
	latV, lonV := obtenerLatLon(v)
	latU, lonU := obtenerLatLon(u)
	sin1 := math.Pow(math.Sin((latV-latU)/2), 2)
	sin2 := math.Pow(math.Sin((lonV-lonU)/2), 2)
	cos1 := math.Cos(latU)
	cos2 := math.Cos(latV)
	return sin1 + cos1 * cos2 * sin2
}

// Regresa el peso aumentado entre dos ciudades
// El peso aumentado es la distancia natural * maxima distancia
func pesoAumentado(i, j int, maxDist float64) float64 {
	dist := distanciaNatural(i, j)
	return dist * maxDist
}

// Copia un arreglo de ciudades, (O de enteros)
// Regresa una copia de actual
func CopiarCiudades(actual []int) []int {
	nuevo := make([]int, len(actual))
	for i := 0; i < len(actual); i++ {
		nuevo[i] = actual[i]
	}
	return nuevo
}

func PrintData(g *General) {
	fmt.Print("Normalizador: ")
	fmt.Printf("%2.15f\n", g.normalizador)
	fmt.Print("Máxima distancia: ")
	fmt.Printf("%2.15f\n", g.maxDist)
	
}

func vecino(sol []int) []int{
	copia := CopiarCiudades(sol)
	i := rand.Intn(len(sol))
	j := rand.Intn(len(sol))
	for i == j {
		i = rand.Intn(len(sol))
	}
	help := copia[i]
	copia[i] = copia[j]
	copia[j] = help
	return copia
}

// func porcentajeAceptados(cities []city, t float64, g General) float64{
func porcentajeAceptados(ids []int, t float64, g General) float64{
	c := 0.0
	i := 1 
	s := CopiarCiudades(ids)
	fmt.Println(s)
	fmt.Println()
	fmt.Println()
	fmt.Println()
	fs := FunCostoSolucion(s, g)
	// fmt.Printf("FS: %2.15f\n", fs)
	for (i < 1000){
		sP := vecino(s)
		fmt.Println(sP)
		fsP := FunCostoSolucion(sP, g)
		// fmt.Printf("FUN COSTO: %2.15f\n", fsP)
		if (fsP < fs + t){
			c++
			s = CopiarCiudades(sP)
			fs = fsP
			// fmt.Println(fs)
		}       
		i++
	}
	// fmt.Printf("porcentaje: %2.15f\n", c/1000.0)
	return c/1000
}

//Funcion para buscar la temparatura inicial correcta
func temperaturaInicial(ids []int, t float64, g General) float64 {	
	p := porcentajeAceptados(ids, t, g)
	fmt.Printf("P-TI: %2.15f\n", p)
	fmt.Println("INIT")
	var t1, t2 float64
	if (math.Abs(P - p) <= EPSILONP){
		return t
	}
	if (p < P){
		for(p < P){
			// fmt.Println("T")
			// fmt.Printf("p-TI: %2.15f\n", p)
			t = 2*t
			// p = porcentajeAceptados(ids, t, g)
			p = P
		}
		t1 = t/2
		t2 = t
	}else{
		for(p > P){
			// fmt.Println("F")
			// fmt.Printf("p-TI: %2.15f\n", p)
			t = t/2
			p = P/2
			// p = porcentajeAceptados(ids, t, g)
		}
		t1 = t
		t2 = 2*t        
	}
	fmt.Println(t1 + t2)
	return 0.0
	// return busquedaBinaria(ids, t1, t2, g)
}

func  main() {  

	//Instancia del TSP
	//Tama;o de la entrada
	var ciudades40 = []int{1,2,3,4,5,6,7,75,163,164,165,168,172,327,329,331,332,333,489,490,491,492,493,496,652,653,654,656,657,792,815,816,817,820,978,979,980,981,982,984}
	// var ciudades40 = []int{1,2,3,4,5,6,7,8,9,11,12,14,16,17,19,20,22,23,25,26,27,74,75,77,163,164,165,166,167,168,169,171,172,173,174,176,179,181,182,183,184,185,186,187,297,326,327,328,329,330,331,332,333,334,336,339,340,343,344,345,346,347,349,350,351,352,353,444,483,489,490,491,492,493,494,495,496,499,500,501,502,504,505,507,508,509,510,511,512,520,652,653,654,655,656,657,658,660,661,662,663,665,666,667,668,670,671,673,674,675,676,678,792,815,816,817,818,819,820,821,822,823,825,826,828,829,832,837,839,840,978,979,980,981,982,984,985,986,988,990,991,995,999,1001,1003,1004,1037,1038,1073,1075}
	seed := 15 //seed
	rand.Seed(int64(seed)) 

	
	distancias := completa(ciudades40) // completa
	totAristas := totalAristas(ciudades40, distancias) //aristasE
	maxDist := totAristas[len(totAristas)-1] //maxDist
	
	distancias = llenaCompleta(ciudades40, distancias, maxDist) //Llena toda la perra gráfica
	
	// fmt.Println(distancias) // toda la perra gráfica
	normalizador := GetNormalizador(totAristas, ciudades40) //normalizador
	

	gen := General{totAristas, distancias, normalizador, maxDist} // datos generales
	
	PrintData(&gen)
	funCosto := FunCostoSolucion(ciudades40, gen)
	//Imprimos el resultado de la funcion costo
	fmt.Print("Funcion Costo: ")
	fmt.Printf("%2.15f\n", funCosto)

	tInicial := temperaturaInicial(ciudades40, 8, gen)
	fmt.Printf("temp inicial:\t%2.15f\n", tInicial)
}
